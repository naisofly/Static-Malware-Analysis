//Was copied from openFile2.c
//WARNING: This file deletes its inputs (unlink()). This helps with identifying non-processed files when the program fails.
//Uses two inputs: 1- the folder (given by CURRPATH) that contains all the extracted syscalls, sorted and uniq.
//		   2- a file that contains the union of all system calls, sorted and uniq too.
//=======
//ulimit -a to display the limits on resources.
//REMEMBER to DELETE the Vectors filE created inside the Vectors folder

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h> 
#include <sys/time.h>
#include <sys/resource.h>
#include <unistd.h>

//       int getrlimit(int resource, struct rlimit *rlim);
//        int setrlimit(int resource, const struct rlimit *rlim);
//RLIM_INFINITY

//#define CURPATH "/home/user/Desktop/Paper/BenignFilesReadyForMatrix/Ordinal_SysCall_PerFile/OnlySysCall/Ready/" //Tested with 
#define CURPATH "/home/tarun/Desktop/DLL/TempSysCalls/"
//#define UDIM 60573 //(00004+Benign)Union File Dimension //+1
#define UDIM 75110 //(Malware+Benign)Union File Dimension //+1

#define MAXSC 3000 //MAXimum number of syscalls done by any single exe file
#define MAXSCNL 1000//120 //MAXimum System Call Name Length
#define CNSDRSCNL 100 //Considered System Call Name Length
//#define SU 10 //Size Used
//#define SM 40 //Size Max
int main()
{
	char * syscalls[MAXSC], *allsyscalls[UDIM];
	int n,i,j,k=0;
	char sc[CNSDRSCNL],ig[MAXSCNL];//syscall[100],ignore[1000];
	DIR           *d;
	struct dirent *dir;

	// should become /home/user/Desktop/Paper/BenignFilesReadyForMatrix/Ordinal_SysCall_PerFile/OnlySysCall/Ready
	FILE *f, *fu, *fo; //fu is the union file, f is the current file (compared against fu)
	//fo contains the vector output of f
	FILE *fm;
	int sc_count=0;
	int NF=1;
	char *M[NF];  // THE FINAL OUTPUT MATRIX
	char pathToOutput[200];
	char pathToOutputFile[300];
	char outputVasS[2*UDIM+1]; //Output vector as a matrix. Contains 1s 0s and separators +\0+\n at the end
	strcpy(pathToOutput, CURPATH);
    	strcat(pathToOutput, "Vectors/");
	printf("%s\n",pathToOutput);
	mkdir(pathToOutput, 0700);
	// LOAD THE UNION FILE
	//if ((fm=fopen("/home/user/Desktop/BenignMatrix.txt","r"))==NULL)
	//{
	//	printf("Error! opening /home/user/Desktop/BenignMatrix.txt");
	//}

	if ((fu=fopen("/home/tarun/Desktop/DLL/sortedUniqCompleteSC.txt","r"))==NULL)
	{
		printf("Error! opening /home/tarun/Desktop/DLL/sortedUniqCompleteSC.txt");
	}
	sc_count=0;
	//allsyscalls[0] = malloc(CNSDRSCNL*sizeof(char));

	while (fscanf(fu, "%s", ig) != EOF) {  //Read a syscall of up to MAXSCNL (e.g. 1000 char)
		if (!(allsyscalls[sc_count] = malloc(CNSDRSCNL*sizeof(char))))
			printf("Malloc failed at %d",sc_count);
		strncpy(allsyscalls[sc_count],ig,CNSDRSCNL-1); //Copy e.g. 99 chars of the syscall into the array
		allsyscalls[sc_count][CNSDRSCNL-1]='\0';  //Terminate the 99 char by the end of string char.

		//printf("%d ---- %s\n",sc_count,allsyscalls[sc_count]); //testing if Union correctly read
		//free(allsyscalls[sc_count]); //DELETE THIS ONE
		sc_count++;
	}
	fclose(fu);  // CLOSE THE FILE

	//for(i=0;i<sc_count;i++)
	//	printf("%s\n",allsyscalls[i]);
	printf("+++++++++++++++++UNION EXTRACTION DONE !+++++++++++++++++++++++++++++++++++++++\n");
	
	int F;
	int i0=0;
	int fn=0; //File Number
// LOOP THROUGH ALL THE FILES IN THE FOLDER

//	for(F=0;F<NF;F++)	
	M[F]=(char *)malloc(UDIM*sizeof(char));//TEMP
	d = opendir(CURPATH);
	F=0;
	char filepath[1000];
	FILE * Xnames;//Create a file to contain the list of files in the same older as they are processed
	//This will be needed to know which vector maps back to which EXE/DLL
	//After reflection, no need for it ! Can be reconstructed from the file names in Vector. This will be more accurate as Xnames might contain file names that were not included (when he program bugs) in the matrix
	strcpy(filepath, "/home/tarun/Desktop/DLL/malwareSCNames");
	if (!(Xnames=fopen(filepath,"w")))
		printf("Problem creating the malwareSCNames file"),exit(5);
	
	
	if (d)
	while ((dir = readdir(d)) != NULL)	
	{
		if(!strcmp(dir->d_name,"Vectors"))
			continue;// once or twice,readdir(d);   //Avoids working on "Vectors" as a file, probably causes a segmentation fault somewhere, could be when deleting it.
		//TEMP M[F]=(char *)malloc(UDIM*sizeof(char)); // A Vector the will be used for each file to stores matches (0 or 1)
		// LOAD AN EXTRACTED FILE
		i0=0;    //Initialise i0 for each file
	        if (!strcmp (dir->d_name, "."))
        	    continue;
        	if (!strcmp (dir->d_name, ".."))    
        	    continue;		

    //char *result = malloc(strlen(s1)+strlen(s2)+1);//+1 for the zero-terminator
    //in real code you would check for errors in malloc here
    		strcpy(filepath, CURPATH);
    		strcat(filepath, dir->d_name);
		
		//printf("File %d: %s\n",fn,filepath);
		if ((f=fopen(filepath,"r"))==NULL)
		//fopen("C:\\program.txt","r"))==NULL){
		{
			printf("Error! opening file %s\n",dir->d_name);
		}
		else
		{
			sc_count=0;
			//syscalls[0] = malloc(CNSDRSCNL*sizeof(char));
			//+++++++++++++++++++++++++++++++++++++FILES WITH ONE COLUMN THAT CONTAINS THE SYSTEM CALL NAME
			//+++++++++++++++++++++++++++++++++++++IF NOT THAT FORMAT, CHANGE THE NUMBER OF %s ACCORDINGLY
			while (fscanf(f, "%s", ig) != EOF) 
			{
				//printf("ig=%s\n",ig);
				if (!(syscalls[sc_count] = malloc(CNSDRSCNL*sizeof(char))))
					printf("Malloc failed at %d for file %s\n",sc_count,dir->d_name);
				//printf("Malloc worked\n");
				strncpy(syscalls[sc_count],ig,CNSDRSCNL-1); //Copy e.g. 99 chars of the syscall into the array
				syscalls[sc_count][CNSDRSCNL-1]='\0';  //Terminate the 99 char by the end of string char.
	
				//printf("%d ---- %s\n",sc_count,syscalls[sc_count]); //testing if file correctly read
				sc_count++;   //Note that sc_count becomes the limit of a following loop
			}
			printf("++++++++++++++++++FILE %d EXTRACTION DONE %s!\n",fn,filepath);
			//for(i=0;i<sc_count;i++)
			//	printf("%s\n",syscalls[i]);
			fclose(f);  
			//unlink(filepath);
			//printf("still fine !\n");	
			for(i=0;i<UDIM;i++)
			{
				//printf("i=%d\n",i);

				M[F][i]=48;   //ZERO in CHAR mode (char)48='0'
			}
			//printf("still fine !\n");
			k=0;
			for(j=0;j<sc_count;j++)
			{
				//printf("still fine j=%d,i0=%d,i=%d\n",j,i0,i);
				for(i=i0;i<UDIM;i++)
				{
					//printf("still fine !\n");
					if(strcmp(syscalls[j], allsyscalls[i]) == 0)
					{
						M[F][i]=49; //ONE in CHAR mode (char)49='1'
						//printf("v[%d]=%d\n",i,M[F][i]);
						k++; // counts how many matches in total for the line
						//printf("			syscalls[%d], allsyscalls[%d]=%s\n.",j,i,syscalls[j]); 
						//Current Number of Matches is %d\n",j,i, syscalls[j],k-1);
						break;				
					}
				}
				//printf("		At the exit of the loop i0=%d,i=%d\n",i0,i);
				i0=i;
			}
			printf("	Final number of matches is %d\n",k);
			fn++;
			//NOW WRITE THE FINAL VECTOR TO A FILE, 1st STEP IS TO CONVERT IT TO A STRING
			//Write once, instead of writing element by element
			strcpy(pathToOutputFile, pathToOutput);
	    		strcat(pathToOutputFile, dir->d_name);
			//printf("Output File %d: %s\n",fn-1,pathToOutputFile);
			if ((fo=fopen(pathToOutputFile,"w"))==NULL) //Write instead of appending. 
			//Better if this has to run several times
			//fopen("C:\\program.txt","r"))==NULL){
			{
				printf("Error! opening file %s\n",dir->d_name);
			}
			else
			{
				for(i=0;i<UDIM;i++)
				{
				
					outputVasS[2*i]=M[F][i];
					outputVasS[2*i+1]=',';
				}
				outputVasS[2*UDIM-1]='\0';
				outputVasS[2*UDIM]='\n';
				//printf("outputVasS = %s",outputVasS);
				fprintf(fo,"%s\n",outputVasS);
				fprintf(Xnames,"%s\n",dir->d_name);
			}
			fclose(fo);
			fflush(stdout);

			//TEMP F++;
		}
	}
	else
		printf("Folder failed to open\n");
	
	fclose(Xnames);

	
	//close(fm);
	return 0;
}
